#include <iostream>
#include <vector>
// #include <string>
#include <memory>
#include <map>
#include <fstream>
#include <algorithm>
#include <set>
#include <iterator>
#include <unordered_set>

# include <ctime>

#include <getopt.h>

#include "scara.h"
#include "SBridger.h"
#include "globals.h"

using namespace std;
using namespace scara;

namespace scara {

int multithreading;

int MinMCPaths, HardNodeLimit, SoftNodeLimit;
int numDFSNodes, maxMCIterations;
float SImin, OHmax;

bool test_short_length, test_contained_reads, test_low_quality;
bool print_output;
double pathGroupHalfSize;

std::string logFile;

DebugLevel globalDebugLevel;
}


// Setting global parameters, variables are defined in globals.h
void setGlobalParameters() {

  // Global variable that determines whether to use multithreading or not
  // Not using multithreading unless specified in the parameters
  scara::multithreading = 0;

  // A minimum number of paths generated by Monte Carlo method
  scara::MinMCPaths = 40;
  // A maximum number of nodes that a path can contain, longer paths will not be generated
  scara::HardNodeLimit = 1000;
  // A number of nodes in a path that will cause a warning to be displayed
  scara::SoftNodeLimit = 100;

  // A number of nodes added to the stack in each step of DFS graph traversal
  scara::numDFSNodes = 5;
  // Maximum number of iterations using Monte Carlo approach
  scara::maxMCIterations = 10000;

  // Minimum sequence identity for filtering overlaps
  scara::SImin = 0.30;
  // Maximum allowed overhang percentage for filtering overlaps
  scara::OHmax = 0.30;

  scara::test_short_length = true;
  scara::test_contained_reads = true;
  scara::test_low_quality = true;

  // Determines if more verbose messages are printed
  // TODO: replace this with DEBUG_LEVEL with multiple levels
  scara::print_output = true;

  // A path is placed in a group if its length falls within pathGtoupHalfSize of groups representative length
  scara::pathGroupHalfSize = 1000;

  // Setting default Debugg level
  scara::globalDebugLevel = DL_DEBUG;

  // Setting Log file
  scara::logFile = "scaraLog.txt";
}

void print_version_message_and_exit() {
  const char* versionmessage = "\nScaRa version 1.3!\n";
  std::cerr << versionmessage;
  exit(0);
}

void print_help_message_and_exit() {
  const char* helpmessage = "\nHow to run ScaRa :"
    "\nScaRa -f (--folder) <Input folder>"
    "\n    or"
    "\nScaRa -r <Reads file> -c <Contigs file> -o <Reads to Contigs Overlaps file> -s <Reads to Reds Overlaps file>"
    "\n    The program will perform one iteration of the algorithm"
    "\n    and output contigs to the standard output!."
    "\n    <Input foder> must contain the following files:"
    "\n    - reads.fastq - reads in FASTQ/FASTA format"
    "\n    - readsToContigs.paf - overlaps between reads and contigs"
    "\n    - readsToReads.paf - overlaps between reads"
    "\n    - contigs.fasta - contigs in FASTA format"
	"\nIf Reads file, Contigs file or Overlaps are specified,"
	"\nthey will not be looked for in the Input folder!"
    "\nOptions:"
    "\n-f (--folder)     specify input folder for ScaRa"
    "\n-r (--reads)      specify reads file for ScaRa"
    "\n-c (--contigs)    specify contigs file ScaRa"
    "\n-o (--overlapsRC)   specify overlaps file for ScaRa"
    "\n-s (--overlapsRR)   specify overlaps file for ScaRa"
    "\n-m (--multithreading)   use multithreading"
    "\n-v (--version)    print program version"
    "\n-h (--help)       print this help message\n";

  std::cerr << helpmessage;
  exit(0);
}

int main(int argc, char **argv)
{

  // KK: Defining basic program nOptions
  const char* const short_opts = "hvr:c:o:s:f:m";
  const option long_opts[] = {
    {"help", no_argument, NULL, 'h'},
    {"version", no_argument, NULL, 'v'},
    {"folder", required_argument, NULL, 'f'},
    {"reads", required_argument, NULL, 'r'},
    {"contigs", required_argument, NULL, 'c'},
    {"overlapsRC", required_argument, NULL, 'o'},
    {"overlapsRR", required_argument, NULL, 's'},
    {"multithreading", no_argument, NULL, 'm'},
    {NULL, no_argument, NULL, 0}
  };

  int readsSet, contigsSet, RCOverlapsSet, RROverlapsSet;
  readsSet = contigsSet = RCOverlapsSet = RROverlapsSet = 0;
  string strData, strReadsFasta, strContigsFasta, strR2COvlPaf, strR2ROvlPaf;

  setGlobalParameters();

  int opt;
  while ((opt = getopt_long(argc, argv, short_opts, long_opts, NULL)) != -1)
    switch(opt) {
    case 'h':
      print_help_message_and_exit();
      break;
    case 'v':
      print_version_message_and_exit();
      break;
    case 'f':
      readsSet = contigsSet = RCOverlapsSet = RROverlapsSet = 1;
      strData = optarg;
      strReadsFasta = strData + "reads.fastq";
      strR2COvlPaf = strData + "readsToContigs.paf";
      strR2ROvlPaf = strData + "readsToReads.paf";
      strContigsFasta = strData + "contigs.fasta";
      break;
    case 'r':
      readsSet = 1;
      strReadsFasta = optarg;
      break;
    case 'c':
      contigsSet = 1;
      strContigsFasta = optarg;
      break;
    case 'o':
      RCOverlapsSet = 1;
      strR2COvlPaf = optarg;
      break;
    case 's':
      RROverlapsSet = 1;
      strR2ROvlPaf = optarg;
      break;
    case 'm':
      scara::multithreading = 1;
      break;
    }

  if (argc < 2 || readsSet == 0 || contigsSet == 0 || RCOverlapsSet == 0 || RROverlapsSet == 0) {
     std::cerr << "\nNot all arguments specified!";
     print_help_message_and_exit();
  }

  std::time_t start_time = std::time(nullptr);
  std::cerr << "\nSCARA: Starting ScaRa: " << std::asctime(std::localtime(&start_time)) << start_time << " seconds since the Epoch";

  std::time_t current_time = std::time(nullptr);
  std::cerr << "\nSCARA: Finished loading: " << std::asctime(std::localtime(&current_time)) << (current_time - start_time) << " seconds since the start\n";

  scara::SBridger sbridger(strReadsFasta, strContigsFasta, strR2COvlPaf, strR2ROvlPaf);

  current_time = std::time(nullptr);
  std::cerr << "\nSCARA: Finished initializing bridger: " << std::asctime(std::localtime(&current_time)) << (current_time - start_time) << " seconds since the start\n";
  std::cerr << "\nSCARA: Generating graph:";

  sbridger.generateGraph();
  sbridger.print();

  current_time = std::time(nullptr);
  std::cerr << "\nSCARA: Finished generating graph: " << std::asctime(std::localtime(&current_time)) << (current_time - start_time) << " seconds since the start\n";
  std::cerr << "\nSCARA: Cleaning up the graph:";

  sbridger.cleanupGraph();
  sbridger.print();

  current_time = std::time(nullptr);
  std::cerr << "\nSCARA: Finished cleaning up the graph: " << std::asctime(std::localtime(&current_time)) << (current_time - start_time) << " seconds since the start\n";
  std::cerr << "\nSCARA: Generating paths:";

  int numPaths = sbridger.generatePaths();

  current_time = std::time(nullptr);
  std::cerr << "\nSCARA: Finished generating paths: " << std::asctime(std::localtime(&current_time)) << (current_time - start_time) << " seconds since the start\n";
  std::cerr << "\nSCARA: Paths generated: " << numPaths;
  std::cerr << "\nSCARA: Grouping and processing paths:";

  int numGroups = sbridger.groupAndProcessPaths();

  current_time = std::time(nullptr);
  std::cerr << "\nSCARA: Finished grouping and processing paths: " << std::asctime(std::localtime(&current_time)) << (current_time - start_time) << " seconds since the start\n";
  std::cerr << "\nSCARA: Final number of path groups: " << numGroups;
  std::cerr << "\nSCARA: Generating sequences:";

  int numSeq = sbridger.generateSequences();

  current_time = std::time(nullptr);
  std::cerr << "\nSCARA: Finished generating sequences: " << std::asctime(std::localtime(&current_time)) << (current_time - start_time) << " seconds since the start\n";
  std::cerr << "\nSCARA: Final number of sequences generated: " << numSeq;

  current_time = std::time(nullptr);
  std::cerr << "\nSCARA: Finished ScaRa run: " << std::asctime(std::localtime(&current_time)) << (current_time - start_time) << " seconds since the start\n";

  return 0;
}